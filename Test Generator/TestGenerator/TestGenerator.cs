using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;



namespace TestGeneratorLib
{
	public class TestGenerator
	{
		public TestContent Generate(string sourceStr)
		{
			var tree = CSharpSyntaxTree.ParseText(sourceStr);
			var root = tree.GetCompilationUnitRoot();

			var sourceNamespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();
			var sourceUsings = root.DescendantNodes().OfType<UsingDirectiveSyntax>();
			var resultUsings = new SyntaxList<UsingDirectiveSyntax>(sourceUsings)
				.AddRange(sourceNamespaces.Select(GetUsingsFromNamespaces))
				.Add(UsingDirective(ParseName("System")))
				.Add(UsingDirective(ParseName("System.Generic.Collections")))
				.Add(UsingDirective(ParseName("System.Linq")))
				.Add(UsingDirective(ParseName("System.Text")))
				.Add(UsingDirective(ParseName("NUnit.Framework")));

			var resultClasses = root.DescendantNodes().OfType<ClassDeclarationSyntax>()
				.Where (resultClass => resultClass.Modifiers.Any(SyntaxKind.PublicKeyword)).ToList();

			var resultMembers = resultClasses.Select(AssembleNamespaces).ToArray();

			var resultUnit = CompilationUnit()
				.WithUsings(resultUsings)
				.AddMembers(resultMembers);

			return new TestContent(resultUnit.NormalizeWhitespace().ToFullString());
		}
		private UsingDirectiveSyntax GetUsingsFromNamespaces (NamespaceDeclarationSyntax namespaceDeclaration)
		{
			return UsingDirective(namespaceDeclaration.Name);
		}

		private MemberDeclarationSyntax AssembleNamespaces (ClassDeclarationSyntax classDeclaration)
		{
			var resultNamespace = NamespaceDeclaration(IdentifierName("Tests"));
			if (classDeclaration.Parent != null)
			{
				resultNamespace = NamespaceDeclaration(QualifiedName((classDeclaration.Parent as NamespaceDeclarationSyntax).Name, IdentifierName("Tests")));
			}

			var resultClass = AssembleClass(classDeclaration);

			resultNamespace = resultNamespace.AddMembers(resultClass);

			return resultNamespace;
		}

		private MemberDeclarationSyntax AssembleClass(ClassDeclarationSyntax classDeclaration)
		{
			var resultAttribute = SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestFixture")))));
			
			var resultModifiers = TokenList(Token(SyntaxKind.PublicKeyword));
			
			var resultMethods = AssembleMethods(classDeclaration);

			var resultClass = ClassDeclaration(classDeclaration.Identifier.Text + "_Test")
				.WithAttributeLists(resultAttribute)
				.WithModifiers(resultModifiers)
				.AddMembers(resultMethods);
			
			return resultClass;
		}

		private MemberDeclarationSyntax[] AssembleMethods(SyntaxNode syntaxNode)
		{
			var resultAttribute = SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("Test")))));
			
			var resultModifiers = TokenList(Token(SyntaxKind.PublicKeyword));

			var resultReturnedType = PredefinedType(Token(SyntaxKind.VoidKeyword));

			var resultBody = Block(ExpressionStatement(InvocationExpression(MemberAccessExpression(
				SyntaxKind.SimpleMemberAccessExpression,IdentifierName("Assert"), IdentifierName("Fail")))
				.WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal("autogenerated"))))))));
			
			var resultMembers = new List<MemberDeclarationSyntax>();
			var sourceMethods = syntaxNode.DescendantNodes().OfType<MethodDeclarationSyntax>()
				.Where(sourceMethod => sourceMethod.Modifiers.Any(SyntaxKind.PublicKeyword)).ToList();

			sourceMethods.Sort((method1, method2) => string.Compare(method1.Identifier.Text, method2.Identifier.Text, StringComparison.Ordinal));

			int i = 0;
			string prevId = sourceMethods[0].Identifier.Text;
			while (i < sourceMethods.Count)
			{
				int overloadCount = 0;
				while (	(i < sourceMethods.Count) &&
						((overloadCount == 0) || (sourceMethods[i].Identifier.Text == prevId)))
				{
					string overloadID = sourceMethods[i].Identifier.Text + (overloadCount == 0 ? "" : overloadCount.ToString()) + "_Test";
					
					resultMembers.Add(MethodDeclaration(resultReturnedType, overloadID)
						.WithAttributeLists(resultAttribute)
						.WithModifiers(resultModifiers)
						.WithParameterList(sourceMethods[i].ParameterList)
						.WithBody(resultBody));

					overloadCount++;
					prevId = sourceMethods[i].Identifier.Text;					
					i++;
				}
			}
			
			return resultMembers.ToArray();
		}
	}
}
